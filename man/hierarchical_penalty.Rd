% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{hierarchical_penalty}
\alias{hierarchical_penalty}
\title{Construct a weighted penalty matrix based on cell type hierarchy}
\usage{
hierarchical_penalty(
  weight.matrix,
  cell.type.hierarchy,
  reference.resolution,
  current.resolution,
  penalty = 1
)
}
\arguments{
\item{weight.matrix}{A square matrix specifying the pairwise distance between cell types}

\item{cell.type.hierarchy}{A data frame containing the cell type hierarchy information. Specifically, each row represents one cell type and each column contains the corresponding cell type annotation at a given granularity.}

\item{reference.resolution}{A character specifying the level of granularity that is used as reference. It must be one of the columns in \code{cell.type.hierarchy}}

\item{current.resolution}{A character specifying the current level of granularity. It is the level of cell type annotation that is used for gene panel selection. It must be one of the columns in \code{cell.type.hierarchy} and should be a lower level compared to \code{reference.resolution}}

\item{penalty}{A numeric value specifying the penalty for misclassifications across cell types at the \code{reference.resolution} level. Default is 1.}
}
\value{
A weighted penalty matrix specifying the partial credit and extra penalty for correct and incorrect classifications between pairs of cell types. This is based on cell type hierarchy information
}
\description{
hierarchical_penalty constructs a weighted penalty matrix based on cell type hierarchy.
}
\details{
During genetic algorithm optimization, a weighted penalty matrix can be provided to give partial credit or extra penalty to classification between certain cell types to reflect custom preference.
The matrix is a square matrix with each row and each column representing one cell type. This is the same with the confusion matrix from classification. For each value \eqn{p_ij} off-diagonal in the weighted penalty matrix,
if \eqn{p_ij > 1}, an extra penalty is given to misclassifying cells from cell type \eqn{j} to cell type \eqn{i}. If \eqn{p_ij < 1}, a partial credit is given to misclassifying cells from cell type \eqn{j} to cell type \eqn{i}.
\eqn{p_ij = 1} means no penalty or partial credit. The weighted penalty matrix is incorporated to the confusion matrix by element-wise multiplication to provide a weighted confusion matrix.

Essentially, the weighted penalty matrix can be constructed arbitrarily by userâ€™s preference. \code{hierarchical_penalty} constructs the weighted penalty matrix from cell type hierarchy.
Input is a square matrix specifying the pairwise distance between cell types (\code{weight.matrix}).
The pairwise distance matrix is then adjusted based on cell type hierarchy (\code{cell.type.hierarchy}) to construct the weighted penalty matrix.
Specifically, cell types can be organized in a hierarchical manner. Each level represents a different granularity
with higher level representing broad cell types (e.g., neuron) and lower level representing detailed cell types that are further divided from broad cell types, i.e., subpopulations (e.g., excitatory neuron and inhibitory neuron).
To adjust the pairwise distance matrix based on cell type hierarchy, a reference level is specified.
For cell types below the reference level that are from the same cell type at the reference level, the pairwise distance (between 0 and 1) between them is kept unchanged to reflect partial credit to wrong classifications among them.
For cell types below the reference level that are from different cell types at the reference level, the pairwise distance between them is changed to \code{penalty} to reflect extra penalty.
This weighted penalty matrix can then be used for hierarchical classification.
}
\examples{
data(sc_count)
data(sc_cluster)
cluster_distance=cluster_dis(count_table = sc_count, cell_cluster_conversion = sc_cluster,
                             cluster_metric = "complete", dist_metric = "correlation",
                             log.transform = FALSE, top.var.gene = 1000)
raw_weight_penalty = as.matrix(cluster_distance$distance_matrix)
raw_weight_penalty = raw_weight_penalty/max(raw_weight_penalty)
weight_penalty = hierarchical_penalty(weight.matrix = raw_weight_penalty,
                                      cell.type.hierarchy = cell_type_hierarchy,
                                      reference.resolution = "class",
                                      current.resolution = "subclass",
                                      penalty = 2)
diag(weight_penalty)=1
}
